# Video stream

## Дано

Видеопоток с веб-камеры в формате mp4

## Задача

2.1. Разработать сервис стриминга с `computer vision object detection`, используя модель `yolov7`

2.2. Реализовать распределенный формат вычислений для сервиса, с использованием фреймворка `Spark (sparkStreaming)`

2.3. В качестве брокеров сообщений допустимо использовать `Apache Kafka` и `Redis`

2.4. Добиться производительности не менее 30 fps на доступных ресурсах, с разрешением 1280х720

---

## Решение

### Общая информация
Решение представляется собой микросверсвисную архитектуру.
Все(*) сервисы обёрнуты в Docker-контейнеры, запускаются одной командой `docker compose up -d --build`. 

1. Брокер сообщений Kafka. Через него общаются сервисы
2. Stream producer. Сервис, который считывает данные видеопотока по сети и пишет в Кафку
3. Pyspark. В PySpark среставми Structured Streming организована обработка входящих изображений.
   Сервис читает картинку в виде байтов из топика Кафки, декодирует, запускает на ней модель детекции,
   визуализирует рамки и пишет в топик для результатов.
4. Stream demo. Простений веб-сервис, который визуализирует изображений, которые получает из топика с результатами. Реализован на FastAPI.

Презентация: [ссылка](https://docs.google.com/presentation/d/1gSb7OFuuXfeUcOst7PTSp9EvDVUvcfTENw5SOQtmM-E/edit?usp=sharing)
Демонстарция: [ссылка](https://drive.google.com/drive/folders/19YvH0i473xn8Nkgdu9sZL43x5JvJeG1W?usp=sharing)

_(*) - сервис Stream producer почему-то не захотел запускаться в контейнере, но его можно запустить локально:_
```commandline
cd video-stream/stream-producer/stream_producer
STREAM_URL='http://211.132.61.124/mjpg/video.mjpg' python -m main
```
Можно так же установить задержку (в секундах) при получении кадров:
`STREAM_URL='http://211.132.61.124/mjpg/video.mjpg' TIMEOUT=1 python -m main`

### Модель детекции
Для детекции использовалась нейронная сеть YOLOv7. Для повышения качества работы для поиска автомобилей,
она была дообучена на датасете [TESI](https://universe.roboflow.com/cv-2022-kyjj6/tesi).
Далее, для удобства работы модель была конвертирована в ONNX и запускалась с ONNXRuntime.
Т.к. в постановке задачи используется оборудование без GPU, но с процессорами Inter, было принято решение использовать запуска OpenVINO.
Модель ONNX была конвертирована в соответствующий формат, что позволило немного ускорить инференс (см. ниже).
Для большей оптимизации данная модель была квантизована (`float32` -> `int8`).


### Сравнение производительности

| Процессор | Размер входного изображения | Фреймворк                 | Время инференса, мс | FPS |
|-----------|-----------------------------|---------------------------|---------------------|-----|
| i5-8300H  | 640x640                     | ONNX Runtime              | 70                  | 14  |
| i5-8300H  | 640x640                     | OpenVINO                  | 52                  | 19  |
| i5-8300H  | 640x640                     | OpenVINO (квантизованная) | 34                  | 29  |
| i5-12400  | 640x640                     | OpenVINO (квантизованная) | 8.9                 | 112 |
| i5-12400  | 640x640                     | ONNX Runtime              | 22                  | 44  |
| i5-12400  | 1280x736                    | ONNX Runtime              | 53                  | 18  |


К сожалению не успел провести замер на квантизованной с разрешением 1280х736,
но из таблицы видно. что квантизация обеспечивает ускорение более, чем в 2 раза,
по сравнению с ONNX Runtime, т.е. ожидаемый FPS >40.


### Проблемы и пути их решения
1. Если не ограничивать поток, то PySpark джоба каждые 10-20-30 секунд подвисает немного.
   Возможно, поможет распараллеливание, но тогда нужно придумать как синхронизировать кадры.
   Пока что со Spark не так хорошо разобрался.
2. Нестабильное получение кадров с помощью Consumer'а. Особенно заметно в веб-демо:
   видео как слайд-шоу или вообще не загружается. Гипотеза 1: это следствие проблемы (1).
   Гипотеза 2: не хватает вычислительных ресурсов локально.
